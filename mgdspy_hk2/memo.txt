

■Hook Bootstrap

□ Dll の場所の問題

HookPoint を持つ dll A が更に別のアセンブリ B に依存していると、
そのアセンブリ B が Hook されたプロセスから見える位置に無いと例外
a. A を他の特別なアセンブリに依存しない様に設計する。
b. B を見える様にしてから (AppDomain.AssemblyResolved 登録)
   B に依存した関数を呼び出す様にする。

  その為には、A に B の位置を通知しなければならない。
  できるだけ、短いコードで B は A から情報を受け取りたい。
  a. 親プロセスに VirtualAllocEx/VirtualWrite で情報を書き込んで貰う。
    hook されるプロセスがプロテクトされていると駄目。
  b. 親プロセスに対して VirtualRead を実行する。
    hook されるプロセスの権限が弱いと駄目。
  c. System.Runtime.Remoting の Ipc で親プロセスが情報を公開
    →公開に使用するクラスは MarshalByRefObject でなければならない。
    ・自分でその様なクラスを用意するとすると、
      結局そのクラスを B に含める (これだと B しか Hook に使えない) か、
      或いは、誰からも見える所に、そのクラスを置いておく必要がある。
    ・或いは、既存の MarshalByRefObject のプロパティを勝手に
      データ受け渡し様に流用する。
  d. 親プロセスの起動 .exe/.dll の場所を取得して、
     それを元にして、B の依存しているライブラリの位置を計算する。


  d. が一番まともである。

□ System.Runtime.Remoting の扱い方

a. 各プロセス毎に channel を開く?
  →然し、Marshal する API が不明。
    RemotingServices.Marshal(obj,"obj", typeof(T));
    で、オブジェクトを公開出来るらしいが、
    どの Channel で公開するのかはどうやって指定するのか?
    (或いは、開いている全ての Channel で同時に公開されるのか?)
  →と思って試したら、
    実は、一つのプロセスでは複数の IpcChannel を開く事はできないらしい。
    (ちゃんと、異なる名前にしても)
    
    因みに、他のプロセスで開いている IpcChannel と同じ名前で、
    新しく IpcChannel を開こうとしてもエラーが発生する。
b. 一つのプロセスで一つの channel を開いて、
    通信用のオブジェクトを、相手プロセス毎に登録する。
    
    結局 a. の方法はそもそも不可能と言う事が分かったので、
    こちらの方法で考える事にする。
    
    然し、a. で問題が生じるという事は、
    潜伏先のプロセスで既に IpcChannel が登録されている場合に、
    新しく IpcChannel を登録しようとしてしまうと、
    エラーが発生するという事になる。
    なので、潜伏先では IpcChannel を作らない様に、
    IpcChannel を作成するのは明示的に実行する必要がある。

□ 一本の Channel で相互通信は可能か?

クライアントでの呼出でサーバーが反応するというのが通常の使い方である。
逆に、サーバーで何か起こったのをクライアントに通知し、
処理をさせるという事は可能だろうか?

(潜伏先で IpcChannel を作成したいが、
IpcChannel はプロセスに一つしか作成出来ないみたいなので、
何とか、mgdspy 側で作成した IpcChannel だけでやりくりしたい。)

a. イベントを MarshalByRefObject に登録しようとしたが、
  Serialization でエラーになった。
b. デリゲートの代わりに何か機能を実装したオブジェクトを
  プロパティに設定してサーバーから呼び出させてみたが、
  やはり、その機能はクライアントで実行されるのではなく、
  サーバー側で実行されてしまう。
  
  更に、そのオブジェクトを MarshalByRefObject から継承させてみたが、
  そうすると、今度は ObjRef はシリアル化出来ませんというエラーになってしまう。
c. 適当に同期を取って何とか実行する方法
  a. Mutex か何かを使って同期する
  b. Marshal されるオブジェクトのプロパティを使用して同期
    ループで回してそのプロパティの変化する瞬間を捕らえるので、
    ずっと無駄な通信を続ける事になり、この方法は良くない。
    (逆に言えば、他のコンピュータとの間でも有効な方法である。
    が、今回はそういう用途は想定していない。)
  c. メッセージループを使用して同期する。
    これは、結局、初めに作った方法と同じである。
    
    違うのは、データのやりとりに Ipc を使うか、それとも SharedMemory を使うかという事になる。
    SharedMemory を使っていた時は、限られた SharedMemory を使用してデータを受け渡しする為に、
    色々と複雑な事を実行したが、Ipc を使用する場合にはそんなに複雑な事はしなくても良い。

    また、もう一つ異なるのは、SharedMemory の時は、mgdspy → hookee の方向の操作しかなかったが、
    Ipc を使用した場合は、hookee → mgdspy の方向への操作が自然に定義されるという事である。


取り敢えずは c. の方法を用いる方向で考える。
Client の方では、
@HookPoint3
  1. サーバからのメッセージを受け取る為のウィンドウを作成する
  2. 作成した事をサーバに通知する。(HWND を Bucket に設定する)
    これは、1. のウィンドウのクラスのコンストラクタで実行すれば OK
と言う事をすれば良い。

□ 実装詳細

Server → Client

□問題点

・操作中、Receiver のスレッドをロックしてしまうという事
  同時に二つ以上、サーバからクライアントに対して操作をする事は出来ない。
  特に、「サーバ→クライアント→サーバ→クライアント」と入れ子になって
  呼出を実行した場合デッドロックする。

  これを解決するには、Receiver での操作は非同期にして、
  待機中 Application.DoEvents を実行する必要がある。

  非同期にする為には…
  1. スレッドを作成する
    毎回作成していると大変である。
  2. ThreadPool
    クライアントから SendMessage を実行する可能性があり、
    その時にはスレッドがロック状態になる。
    共有の ThreadPool のスレッドでスリープをしていると、
    実働のスレッドが減ってしまい、不味い。
  3. 自分で、ThreadPool 様の物を作成する。
    →どの様な実装にするのか?
      現在必要なタスクの数に応じて幾らでもスレッドが増えていく ThreadPool ?
      (問題は発生しないだろうか?)
  
  或いは、寧ろ、初めから全て非同期とするか…。
  同期は使用者側で行う…。
  →としても、同じ問題が生じる。
    使用者側でスレッドをけちって　ThreadPool を使い、
    同期の為に Sleep を実行すると結局 ThreadPool のスレッドを浪費するだけである。
  →なので、やはり、必要になるだろうと思われる同期の機構は、
    ライブラリレベルで実装しておく方が良い。
  
  
  
  
  
  